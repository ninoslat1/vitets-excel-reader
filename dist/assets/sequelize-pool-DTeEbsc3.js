var g={},u={},_;function p(){if(_)return u;_=1,Object.defineProperty(u,"__esModule",{value:!0}),u.TimeoutError=void 0;let i=class extends Error{};return u.TimeoutError=i,u}var l={},m;function O(){if(m)return l;m=1,Object.defineProperty(l,"__esModule",{value:!0}),l.AggregateError=void 0;let i=class j extends Error{constructor(n){super(),this.errors=n,this.name="AggregateError"}toString(){return`AggregateError of:
${this.errors.map(s=>s===this?"[Circular AggregateError]":s instanceof j?String(s).replace(/\n$/,"").replace(/^/gm,"  "):String(s).replace(/^/gm,"    ").substring(2)).join(`
`)}
`}};return l.AggregateError=i,l}var h={},c={},b;function T(){if(b)return c;b=1,Object.defineProperty(c,"__esModule",{value:!0}),c.Deferred=void 0;const i=p();let a=class{constructor(){this._promise=new Promise((s,e)=>{this._reject=e,this._resolve=s})}registerTimeout(s,e){this._timeout||(this._timeout=setTimeout(()=>{e(),this.reject(new i.TimeoutError("Operation timeout"))},s))}_clearTimeout(){this._timeout&&clearTimeout(this._timeout)}resolve(s){this._clearTimeout(),this._resolve(s)}reject(s){this._clearTimeout(),this._reject(s)}promise(){return this._promise}};return c.Deferred=a,c}var f;function w(){if(f)return h;f=1,Object.defineProperty(h,"__esModule",{value:!0}),h.Pool=void 0;const i=T(),a=O();let n=class{constructor(e){if(this.log=!1,!e.create)throw new Error("create function is required");if(!e.destroy)throw new Error("destroy function is required");if(!e.validate)throw new Error("validate function is required");if(typeof e.min!="number"||e.min<0||e.min!==Math.round(e.min))throw new Error("min must be an integer >= 0");if(typeof e.max!="number"||e.max<=0||e.max!==Math.round(e.max))throw new Error("max must be an integer > 0");if(e.min>e.max)throw new Error("max is smaller than min");if(e.maxUses!==void 0&&(typeof e.maxUses!="number"||e.maxUses<0))throw new Error("maxUses must be an integer >= 0");this.idleTimeoutMillis=e.idleTimeoutMillis||3e4,this.acquireTimeoutMillis=e.acquireTimeoutMillis||3e4,this.reapIntervalMillis=e.reapIntervalMillis||1e3,this.maxUsesPerResource=e.maxUses||1/0,this.log=e.log||!1,this._factory=e,this._count=0,this._draining=!1,this._pendingAcquires=[],this._inUseObjects=[],this._availableObjects=[],this._removeIdleScheduled=!1}get size(){return this._count}get name(){return this._factory.name}get available(){return this._availableObjects.length}get using(){return this._inUseObjects.length}get waiting(){return this._pendingAcquires.length}get maxSize(){return this._factory.max}get minSize(){return this._factory.min}_log(e,r){typeof this.log=="function"?this.log(e,r):this.log&&console.log(`${r.toUpperCase()} pool ${this.name||""} - ${e}`)}_removeIdle(){const e=[],r=Date.now();let t,o=this._availableObjects.length;const E=this.size-this.minSize;let d;for(this._removeIdleScheduled=!1,t=0;t<o&&E>e.length;t++)d=this._availableObjects[t].timeout,r>=d&&(this._log("removeIdle() destroying obj - now:"+r+" timeout:"+d,"verbose"),e.push(this._availableObjects[t].resource));e.forEach(this.destroy,this),o=this._availableObjects.length,o>0?(this._log("this._availableObjects.length="+o,"verbose"),this._scheduleRemoveIdle()):this._log("removeIdle() all objects removed","verbose")}_scheduleRemoveIdle(){this._removeIdleScheduled||(this._removeIdleScheduled=!0,this._removeIdleTimer=setTimeout(()=>{this._removeIdle()},this.reapIntervalMillis))}_dispense(){let e=null;const r=this._pendingAcquires.length;if(this._log(`dispense() clients=${r} available=${this._availableObjects.length}`,"info"),!(r<1)){for(;this._availableObjects.length>0;){if(this._log("dispense() - reusing obj","verbose"),e=this._availableObjects[this._availableObjects.length-1],!this._factory.validate(e.resource)){this.destroy(e.resource);continue}return this._availableObjects.pop(),this._addResourceToInUseObjects(e.resource,e.useCount),this._pendingAcquires.shift().resolve(e.resource)}this.size<this.maxSize&&this._createResource()}}_createResource(){this._count+=1,this._log(`createResource() - creating obj - count=${this.size} min=${this.minSize} max=${this.maxSize}`,"verbose"),this._factory.create().then(e=>{const r=this._pendingAcquires.shift();r?(this._addResourceToInUseObjects(e,0),r.resolve(e)):this._addResourceToAvailableObjects(e,0)}).catch(e=>{const r=this._pendingAcquires.shift();this._count-=1,this._count<0&&(this._count=0),r&&r.reject(e),process.nextTick(()=>{this._dispense()})})}_addResourceToAvailableObjects(e,r){const t={resource:e,useCount:r,timeout:Date.now()+this.idleTimeoutMillis};this._availableObjects.push(t),this._dispense(),this._scheduleRemoveIdle()}_addResourceToInUseObjects(e,r){const t={resource:e,useCount:r};this._inUseObjects.push(t)}_ensureMinimum(){let e,r;if(!this._draining&&this.size<this.minSize)for(r=this.minSize-this.size,e=0;e<r;e++)this._createResource()}acquire(){if(this._draining)return Promise.reject(new Error("pool is draining and cannot accept work"));const e=new i.Deferred;return e.registerTimeout(this.acquireTimeoutMillis,()=>{this._pendingAcquires=this._pendingAcquires.filter(r=>r!==e)}),this._pendingAcquires.push(e),this._dispense(),e.promise()}release(e){if(this._availableObjects.some(o=>o.resource===e)){this._log("release called twice for the same resource: "+new Error().stack,"error");return}const r=this._inUseObjects.findIndex(o=>o.resource===e);if(r<0){this._log("attempt to release an invalid resource: "+new Error().stack,"error");return}const t=this._inUseObjects[r];t.useCount+=1,t.useCount>=this.maxUsesPerResource?(this._log("release() destroying obj - useCount:"+t.useCount+" maxUsesPerResource:"+this.maxUsesPerResource,"verbose"),this.destroy(t.resource),this._dispense()):(this._inUseObjects.splice(r,1),this._addResourceToAvailableObjects(t.resource,t.useCount))}async destroy(e){const r=this._availableObjects.length,t=this._inUseObjects.length;if(this._availableObjects=this._availableObjects.filter(o=>o.resource!==e),this._inUseObjects=this._inUseObjects.filter(o=>o.resource!==e),r===this._availableObjects.length&&t===this._inUseObjects.length){this._ensureMinimum();return}this._count-=1,this._count<0&&(this._count=0);try{await this._factory.destroy(e)}finally{this._ensureMinimum(),this._draining||process.nextTick(()=>{this._dispense()})}}drain(){this._log("draining","info"),this._draining=!0;const e=r=>{if(this._pendingAcquires.length>0){this._dispense(),setTimeout(()=>{e(r)},100);return}if(this._availableObjects.length!==this._count){setTimeout(()=>{e(r)},100);return}r()};return new Promise(r=>e(r))}async destroyAllNow(){this._log("force destroying all objects","info"),this._removeIdleScheduled=!1,clearTimeout(this._removeIdleTimer);const e=this._availableObjects.map(t=>t.resource),r=[];for(const t of e)try{await this.destroy(t)}catch(o){this._log("Error destroying resource: "+o.stack,"error"),r.push(o)}if(r.length>0)throw new a.AggregateError(r)}};return h.Pool=n,h}var v;function P(){return v||(v=1,function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.Pool=i.AggregateError=i.TimeoutError=void 0;var a=p();Object.defineProperty(i,"TimeoutError",{enumerable:!0,get:function(){return a.TimeoutError}});var n=O();Object.defineProperty(i,"AggregateError",{enumerable:!0,get:function(){return n.AggregateError}});var s=w();Object.defineProperty(i,"Pool",{enumerable:!0,get:function(){return s.Pool}})}(g)),g}export{P as r};
